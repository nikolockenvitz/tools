<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Decision Matrix</title>
		<style>
			body {
				background: #333;
				color: #ccc;
				caret-color: #ccc;
				height: 100%;
				margin: 0;
				padding: 10px;
				font-family: "Courier New", Courier, monospace;
			}
			table {
				border-collapse: collapse;
				min-width: 100%;
			}
			tr {
				border-top: 1px solid #ccc;
			}
			tr:first-child {
				border-top: none;
			}
			td {
				padding: 10px;
				border-left: 1px solid #ccc
			}
			td:first-child {
				border-left: none;
			}
			tr td p {
				display: inline-block;
				/*background-color: #00f;*/
				margin: 0;
			}
			p[draggable='false'] {
				/* draggable is explicitly set to false for childs of draggable table cells (first row/column) */
				margin-top: 3px;
			}
			p:focus {
				outline: none;
			}
			.draggable {
				cursor: grab;
			}
			.draggable::before {
				content: "â˜° ";
				vertical-align: top;
			}
			.draggable * {
				cursor: text;
			}
			#buttons {
				margin-bottom: 10px;
			}
			#buttons button {
				background-color: #66ad57;
				border: none;
				color: #fff;
				text-align: center;
				padding: 0.5em 1em;
				margin: 0 1px;
			}
			#buttons button:hover {
				background-color: #76bd67;
			}
			#buttons button#btn-delete {
				background-color: #f0142f;
			}
		</style>
	</head>
<!--
	TODOs:
	 - auto-save and export
-->
	<body>
		<div id="buttons">
			<button onclick="addRow()">Add Criteria (Row)</button>
			<button onclick="addColumn()">Add Alternative (Column)</button>
			<button id="btn-delete">Delete</button>
		</div>

		<table id="table" spellcheck="false">
			<tr>
				<td></td>
				<td>Weight</td>
				<td><p contenteditable="true">Alternative 1</p></td>
				<td><p contenteditable="true">Alternative 2</p></td>
			</tr>
			<tr>
				<td><p contenteditable="true">Criteria 1</p></td>
				<td><p contenteditable="true">5</p></td>
				<td><p contenteditable="true">1</p></td>
				<td><p contenteditable="true">2</p></td>
			</tr>
			<tr>
				<td><p contenteditable="true">Criteria 2</p></td>
				<td><p contenteditable="true">6</p></td>
				<td><p contenteditable="true">3</p></td>
				<td><p contenteditable="true">4</p></td>
			</tr>
			<tr>
				<td>Score</td>
				<td></td>
				<td></td>
				<td></td>
			</tr>
		</table>

		<script type="text/javascript">
			let temporarilyDragDisabledCells = [];
			let dataTransferDrag = "";

			let showElement = function (el) { el.style.display = ""; };
			let hideElement = function (el) { el.style.display = "none"; };

			window.onload = function() {
				let table = document.getElementById("table");
				let rows = table.rows;

				// make columns draggable (except first and second)
				for (let i=2; i<rows[0].cells.length; i++) {
					enableDragAndDropForCell(rows[0].cells[i]);
				}
				// make rows draggable (except first and last)
				for (let i=1; i<rows.length-1; i++) {
					enableDragAndDropForCell(rows[i].cells[0]);
				}

				// disable drop for all contenteditable-fields
				let elements = document.querySelectorAll('[contenteditable="true"]');
				disableDropForElements(elements);

				// delete widget
				let el = document.getElementById("btn-delete");
				enableDropForDeleteWidget(el);
				document.addEventListener("dragstart", function (e) {
					showElement(el);
				});
				document.addEventListener("dragend", function (e) {
					hideElement(el);
				});
				hideElement(el);

				window.addEventListener('mouseup', function(e) {
					// drag needs to be disabled when user clicks in childs of cell
					// -> enable drag again when mouse is released
					for (let el of temporarilyDragDisabledCells) {
						el.draggable = true;
					}
					temporarilyDragDisabledCells = [];

					// if user clicks next to "input" then get focus
					if (e.target.tagName === "TD") {
						for (let child of e.target.children) {
							if (child.tagName === "P" &&
								child.getAttribute("contenteditable") === "true") {
								child.focus();
								break;
							}
						}
					}
				});

				// update score-row if values change
				document.addEventListener("input", function (e) {
					let cell = e.target.parentNode;
					let { rowIndex, cellIndex } = getRowAndCellIndexOfCell(cell);

					// split into grade and comment
					/*let pElement = document.getElementById("table").rows[rowIndex].cells[cellIndex].children[0];
					let text = pElement.innerText;
					//console.log(window.getSelection());
					let x = "<span class='number'>";
					let i = 0;
					while (true) {
						if (isNaN(text[i]) || i >= text.length) {
							break;
						}
						x += text[i++];
					}
					x += "</span>";
					x += "<span class='comment'>" + text.substring(i) + "</span>";
					pElement.innerHTML = x;*/

					// update last row of table (score)
					if (rowIndex >= 1 && cellIndex >= 1) {
						updateScores();
					}
				});

				updateScores();
			};

			let enableDragAndDropForCell = function (cell) {
				cell.draggable = true;
				for (let child of cell.children) {
					child.draggable = false;
					child.addEventListener('mousedown', function(e) {
						e.stopPropagation();
						disableDragForCellTemporarily(child.parentNode);
					});
				}
				cell.ondragstart = drag;
				cell.ondragover = checkWhetherDropAllowed;
				cell.ondrop = drop;
				cell.classList.add("draggable");
			};

			let disableDropForElements = function (elements) {
				for (let element of elements) {
					element.addEventListener("drop", function (e) {
						e.preventDefault();
						return false;
					});
					element.parentNode.addEventListener("drop", function (e) {
						e.preventDefault();
						return false;
					});
				}
			};

			let enableDropForDeleteWidget = function (el) {
				el.ondragover = function (e) { e.preventDefault(); };
				el.ondrop = function (e) {
					e.preventDefault();
					let data = getDataForDrag(e);
					let { rowIndex, cellIndex } = getRowAndCellIndexOfCellId(data);
					if (rowIndex === 0) {
						deleteColumn(cellIndex);
					} else if (cellIndex === 0) {
						deleteRow(rowIndex);
						updateScores();
					}
					hideElement(el);
				}
			};

			let deleteColumn = function (columnIndex) {
				for (let row of document.getElementById("table").rows) {
					row.deleteCell(columnIndex);
				}
			};

			let deleteRow = function (rowIndex) {
				document.getElementById("table").deleteRow(rowIndex);
			};

			let updateScores = function () {
				let table = document.getElementById("table");
				let rows = table.rows;
				for (let c=2; c<rows[0].cells.length; c++) {
					let score = 0;
					for (let r=1; r<rows.length-1; r++) {
						let grade = +rows[r].cells[c].children[0].innerText.split(/\s/,1)[0]; // read number only until first whitespace
						let weight = +rows[r].cells[1].children[0].innerText.split(/\s/,1)[0];
						score += grade * weight;
					}
					rows[rows.length-1].cells[c].innerText = score;
				}
			};

			let disableDragForCellTemporarily = function (cell) {
				temporarilyDragDisabledCells.push(cell);
				cell.draggable = false;
			};
			let getDataForDrag = function (e) {
				let data = e.dataTransfer.getData("text");
				if (data === "") {
					if (dataTransferDrag === "") {
						// unknown error
					} else {
						// e.dataTransfer is not working in Chrome
						data = dataTransferDrag;
						//alert("Please use Firefox!");
					}
				}
				return data;
			};

			let drag = function (e) {
				let id = getCellId(e.srcElement);
				e.dataTransfer.setData("text", id);
				dataTransferDrag = id;
			};

			let checkWhetherDropAllowed = function (e) {
				let data = getDataForDrag(e);
				let from = getRowAndCellIndexOfCellId(data);
				let to = getRowAndCellIndexOfCell(e.srcElement);

				if (isDroppable(from, to)) {
					e.preventDefault();
				}
			};

			let isDroppable = function (from, to) {
				// mustn't be same cell but at least row- or cell-index have to be 0
				if ( !(from.rowIndex === to.rowIndex &&
						from.cellIndex === to.cellIndex) &&
					( (from.rowIndex === 0 && to.rowIndex === 0) ||
					(from.cellIndex === 0 && to.cellIndex === 0) ) ) {
					
					return true;
				}
				return false;
			}

			let drop = function (e) {
				e.preventDefault();
				let data = getDataForDrag(e);
				let from = getRowAndCellIndexOfCellId(data);
				let to = getRowAndCellIndexOfCell(e.srcElement);

				if (!isDroppable(from, to)) {
					return false;
				}

				if (from.rowIndex === 0 && to.rowIndex === 0) {
					// move column
					let content = [];
					for (let row of document.getElementById("table").rows) {
						content.push(row.cells[from.cellIndex].innerText);
					}
					deleteColumn(from.cellIndex);
					addColumn(to.cellIndex, content);
				} else if (from.cellIndex === 0 && to.cellIndex === 0) {
					// move row
					let content = [];
					for (let cell of document.getElementById("table").rows[from.rowIndex].cells) {
						content.push(cell.innerText);
					}
					deleteRow(from.rowIndex);
					addRow(to.rowIndex, content);
				}
				dataTransferDrag = "";

			};

			let getCellId = function (cell) {
				let { rowIndex, cellIndex } = getRowAndCellIndexOfCell(cell);
				return "cell-" + rowIndex + "-" + cellIndex;
			}
			let getRowAndCellIndexOfCell = function (cell) {
				while (cell.cellIndex === undefined) {
					// function was probably called with child of cell
					cell = cell.parentNode;
				}
				return { rowIndex: cell.parentNode.rowIndex,
						 cellIndex: cell.cellIndex };
			};
			let getRowAndCellIndexOfCellId = function (cellId) {
				let temp = cellId.split("-");
				return { rowIndex: +temp[1],
						 cellIndex: +temp[2] };
			}

			let cellTemplate = '<td><p contenteditable="true">{content}</p></td>';

			let addRow = function (rowIndex, content) {
				let table = document.getElementById("table");

				if (rowIndex === undefined) {
					rowIndex = table.rows.length-1;
				}
				if (content === undefined) {
					content = ["Criteria"];
				}

				let newRow = table.insertRow(rowIndex);

				for (let i=0; i<table.rows[0].cells.length; i++) {
					newRow.insertCell(-1).innerHTML = cellTemplate.replace("{content}", content.length > i ? content[i] : "0");
				}

				enableDragAndDropForCell(newRow.cells[0]);

				let elements = newRow.querySelectorAll('[contenteditable="true"]');
				disableDropForElements(elements);
			};

			let addColumn = function (columnIndex, content) {
				let rows = document.getElementById("table").rows;
				let addedCells = [];

				if (columnIndex === undefined) {
					columnIndex = rows[0].cells.length;
				}
				if (content === undefined) {
					content = ["Alternative"];
				}

				let cell;
				for (let i=0; i<rows.length; i++) {
					cell = rows[i].insertCell(columnIndex);
					cell.innerHTML = cellTemplate.replace("{content}", content.length > i ? content[i] : "0");
					addedCells.push(cell);
				}

				enableDragAndDropForCell(rows[0].cells[columnIndex]);

				for (let addedCell of addedCells) {
					disableDropForElements(addedCell.querySelectorAll('[contenteditable="true"]'));
				}
			};
		</script>
	</body>
</html>